\subsection{Descripción del problema.}

\vspace*{0.3cm}

Se tiene un juego de mesa cuyo tablero, dividido en casillas, posee igual cantidad de filas y columnas y hace uso de una conocida pieza del popular ajedrez: el caballo. El juego es solamente para un jugador y consiste en, teniendo caballos ubicados en distintos casilleros, insertar en casilleros vacíos la mínima cantidad de caballos extras, de manera tal que, siguendo las reglas del movimiento de los caballos en el ajedrez, todas las casillas se encuentren ocupadas o amenazadas por un caballo.
Aspectos a tener en cuenta:

\begin{itemize}
   \item Se conoce la cantidad de filas y columnas del tablero
   \item Se conoce la cantidad de caballos que ocupan el tablero inicialmente.
   \item Para cada uno de estos caballos, se sabe su ubicación en el tablero
   \item Una casilla se considera amenazada si existe un caballo tal que en una movida pueda ocupar dicha casilla
\end{itemize}

%\begin{figure}[htb]
%  \begin{center}
%      \includegraphics[scale=0.25]{imagenes/ejemplo.jpg}
%  \end{center}
%  \caption{ejemplo}
%\end{figure}

\vspace*{0.6cm}

%\newpage
\subsection{Desarrollo de la idea y pseudocódigo.}

\vspace*{0.3cm}

%\textbf{completar!}

%\begin{codebox}
%\Procname{$\proc{ejemplo_de_pseudocodigo}(x,y)$}
%\li \Return $\id{solucion}$
%\end{codebox}

\vspace*{0.6cm}

%\newpage
\subsection{Justificación de la resolución y demostración de correctitud.}

\vspace*{0.3cm}

%\textbf{completar!}

\vspace*{0.6cm}

%\newpage
\subsection{Análisis de complejidad.}

\vspace*{0.3cm}


\begin{figure}
\begin{codebox}
\Procname{$\proc{Backtracking}(Tablero$ $tab, Tablero$ $tab$_$final, int$ $fila, int$ $columna, int$ $n)$}
\li copia_tab $\leftarrow$ tablero vacío de n x n // $\mathcal{O}(1)$
\li \If agregué más caballos de los que permitía la cota   // $\mathcal{O}(1)$
\li \quad \Return   
\li \If ya llené el tablero                                // $\mathcal{O}(1)$
\li \quad tab_final $\leftarrow$ copia de tab              // $\mathcal{O}(n^2)$
\li \quad cota $\leftarrow$ cantidad de caballos agregados        // $\mathcal{O}(1)$
\li \quad \Return
\li \If ya recorrí todo el tablero
\li \quad \Return
\li f $\leftarrow$ fila para la siguiente llamada recursiva  // $\mathcal{O}(1)$
\li c $\leftarrow$ columna para la siguiente llamada recursiva  // $\mathcal{O}(1)$
\li \If en tab[fila][columna] había un caballo preubicado      // $\mathcal{O}(1)$
\li \quad copia_tab $\leftarrow$ copia de tab              // $\mathcal{O}(1)$
\li \quad r $\leftarrow$ cantidad de casillas que falta llenar  //$\mathcal{O}(1)$
\li \quad e $\leftarrow$ cantidad de caballos agregados hasta ahora $\mathcal{O}(1)$
\li \quad \If copia_tab[fila][columna] no está cubierta
\li \quad \quad r- -
\li \quad copia_tab[fila][columna] $\leftarrow$ coloco un caballo extra y setea las casillas que amenaza ese nuevo caballo extra    \\   // $\mathcal{O}(1)$
\li \quad e++          // $\mathcal{O}(1)$
\li \quad {\it Backtraking}(copia_tab,tab_final,f,c,n) \\
//Hago la llamada recursiva a backtracking con el nuevo tablero y los datos actualizados \\
teniendo en cuenta el caballo extra
\li {\it Backtraking}(tab,tab_final,f,c,n)\\
//Llamo a backtracking con el tablero nuevo que no tiene asignado el caballo extra
\end{codebox}
\caption{Pseudocódigo del backtraking}\label{code:backtraking}
\end{figure}
\FloatBarrier

\begin{figure}
\begin{codebox}
\Procname{$\proc{El_señor_de_los_caballos}$} 
\li n $\leftarrow$ tamaño del tablero //tomado por la entrada estándar
\li k $\leftarrow$ cantidad de caballos preubicados //tomado por la entrada estándar
\li extras $\leftarrow$ 0
\li tab $\leftarrow$ tablero de n x n vacío // $\mathcal{O}(1)$
\li tab_final $\leftarrow$ tablero de n x n vacío donde irá el resultado // $\mathcal{O}(1)$
\li tab $\leftarrow$ setear ubicación de los caballos preubicadosy las casillas que amenaza cada uno.
\li falta_cubrir $\leftarrow$ cantidad de casillas no ocupadas $\mathcal{O}(1)$
\li \If ($n < 5$)
\li \quad cota $\leftarrow$ 4  // $\mathcal{O}(1)$
\li \Else
\li \quad cota $\leftarrow$ $n*\left \lceil \dfrac{n}{5} \right \rceil$   // $\mathcal{O}(1)$
\li {\it Backtracking}(tab,tab_final,0,0,n)
\li //función que, usando la técnica de backtracking arma el tablero de salida y calcula en\\ extras la cantidad de caballos agregados
\li Muestro por pantalla: cantidad de caballos agregados\\la posición de cada caballo extra
\end{codebox}
\caption{Pseudocódigo de El señor de los caballos}\label{code:caballos}
\end{figure}
\FloatBarrier

\vspace*{0.6cm}

%\newpage
\subsection{Experimentación y gráficos.}

\vspace*{0.3cm}

\subsubsection{Test 1}

\vspace*{0.3cm}

\textbf{completar!}


\newpage
\subsubsection{Test 2}

\vspace*{0.3cm}

\textbf{completar!}


\newpage
\subsubsection{Test 3}

\vspace*{0.3cm}

\textbf{completar!}
