\subsection{Descripción del problema.}

\vspace*{0.3cm}

Se tiene un juego de mesa cuyo tablero, dividido en casillas, posee igual cantidad de filas y columnas y hace uso de una conocida pieza del popular ajedrez: el caballo. El juego es solamente para un jugador y consiste en, teniendo caballos ubicados en distintos casilleros, insertar en casilleros vacíos la mínima cantidad de caballos extras, de manera tal que, siguendo las reglas del movimiento de los caballos en el ajedrez, todas las casillas se encuentren ocupadas o amenazadas por un caballo.
Aspectos a tener en cuenta:

\begin{itemize}
   \item Se conoce la cantidad de filas y columnas del tablero
   \item Se conoce la cantidad de caballos que ocupan el tablero inicialmente.
   \item Para cada uno de estos caballos, se sabe su ubicación en el tablero
   \item Una casilla se considera amenazada si existe un caballo tal que en una movida pueda ocupar dicha casilla
\end{itemize}

%\begin{figure}[htb]
%  \begin{center}
%      \includegraphics[scale=0.25]{imagenes/ejemplo.jpg}
%  \end{center}
%  \caption{ejemplo}
%\end{figure}

\vspace*{0.6cm}

%\newpage
\subsection{Desarrollo de la idea y pseudocódigo.}

\vspace*{0.3cm}

%\textbf{completar!}

%\begin{codebox}
%\Procname{$\proc{ejemplo_de_pseudocodigo}(x,y)$}
%\li \Return $\id{solucion}$
%\end{codebox}

\vspace*{0.6cm}

%\newpage
\subsection{Justificación de la resolución y demostración de correctitud.}

\vspace*{0.3cm}

%\textbf{completar!}

\vspace*{0.6cm}

%\newpage
\subsection{Análisis de complejidad.}

\vspace*{0.3cm}


\begin{figure}
\begin{codebox}
\Procname{$\proc{Backtracking}(Tablero$ $tab, Tablero$ $tab$_$final, int$ $fila, int$ $columna, int$ $n)$}
\li copia_tab $\leftarrow$ tablero vacío de n x n // $\mathcal{O}(1)$
\li \If agregué más caballos de los que permitía la cota   // $\mathcal{O}(1)$
\li \quad \Return   
\li \If ya llené el tablero                                // $\mathcal{O}(1)$
\li \quad tab_final $\leftarrow$ copia de tab              // $\mathcal{O}(n^2)$
\li \quad cota $\leftarrow$ cantidad de caballos agregados        // $\mathcal{O}(1)$
\li \quad \Return
\li \If ya recorrí todo el tablero
\li \quad \Return
\li f $\leftarrow$ fila para la siguiente llamada recursiva  // $\mathcal{O}(1)$
\li c $\leftarrow$ columna para la siguiente llamada recursiva  // $\mathcal{O}(1)$
\li \If en tab[fila][columna] no había un caballo preubicado      // $\mathcal{O}(1)$
\li \quad copia_tab $\leftarrow$ copia de tab              // $\mathcal{O}(n^2)$
\li \quad r $\leftarrow$ cantidad de casillas que falta llenar  //$\mathcal{O}(1)$
\li \quad e $\leftarrow$ cantidad de caballos agregados hasta ahora $\mathcal{O}(1)$
\li \quad \If copia_tab[fila][columna] no está cubierta
\li \quad \quad r- -
\li \quad copia_tab[fila][columna] $\leftarrow$ coloco un caballo extra y setea las casillas que amenaza ese nuevo caballo extra    \\   // $\mathcal{O}(1)$
\li \quad e++          // $\mathcal{O}(1)$
\li \quad {\it Backtraking}(copia_tab,tab_final,f,c,n) \\
//Hago la llamada recursiva a backtracking con el nuevo tablero y los datos actualizados \\
teniendo en cuenta el caballo extra
\li {\it Backtraking}(tab,tab_final,f,c,n)\\
//Llamo a backtracking con el tablero nuevo que no tiene asignado el caballo extra
\end{codebox}
\caption{Pseudocódigo del backtraking}\label{code:backtraking}
\end{figure}
\FloatBarrier

\begin{figure}
\begin{codebox}
\Procname{$\proc{El_señor_de_los_caballos}$} 
\li n $\leftarrow$ tamaño del tablero //tomado por la entrada estándar
\li k $\leftarrow$ cantidad de caballos preubicados //tomado por la entrada estándar
\li extras $\leftarrow$ 0
\li tab $\leftarrow$ tablero de n x n vacío // $\mathcal{O}(1)$
\li tab_final $\leftarrow$ tablero de n x n vacío donde irá el resultado // $\mathcal{O}(1)$
\li tab $\leftarrow$ setear ubicación de los caballos preubicadosy las casillas que amenaza cada uno.
\li falta_cubrir $\leftarrow$ cantidad de casillas no ocupadas $\mathcal{O}(1)$
\li \If ($n < 5$)
\li \quad cota $\leftarrow$ 4  // $\mathcal{O}(1)$
\li \Else
\li \quad cota $\leftarrow$ $n*\left \lceil \dfrac{n}{5} \right \rceil$   // $\mathcal{O}(1)$
\li {\it Backtracking}(tab,tab_final,0,0,n)
\li //función que, usando la técnica de backtracking arma el tablero de salida y calcula en\\ extras la cantidad de caballos agregados
\li Muestro por pantalla: cantidad de caballos agregados\\la posición de cada caballo extra
\end{codebox}
\caption{Pseudocódigo de El señor de los caballos}\label{code:caballos}
\end{figure}
\FloatBarrier

Ahora procederemos a demostrar que el algoritmo que planteamos posee una complejidad de $\mathcal{O}(n^2*2^{n^2})$. Luego de un simple vistazo al pseudocodigo (Figura \ref{code:caballos}) se puede ver que la complejidad deriva en gran medida de lo que sucede cuando se llama a la función encargada del backtracking, dado que las comparaciones realizadas son $\mathcal{O}(1)$ asi como las asignaciones. La complejidad de copiar la entrada y generar el tablero adecuado nos resulta $\mathcal{O}(n^2)$.\\
Analicemos ahora un caso particular, como el de un tablero de 2x2 sin caballos preubicados. Haciendo un leve seguimiento del pseudocodigo (Figura \ref{code:backtraking}) nos encontramos revisando la primer casilla del tablero y dado que no hay un caballo preubicado se generan 2 instancias, un nuevo tablero con un caballo extra en esa posicion y otro en el que este no se encuentra presente. La creación de este nuevo tablero nos cuesta $\mathcal{O}(n^2)$. Sobre estas dos instancias se vuelve a llamar a la función de backtracking y el proceso se repite ahora con la casilla siguiente, y asi hasta cubrir las $n*n$ casillas. Al terminar el recorrido notamos que contamos con 15 instancias ($2^{n^2} - 1$) y que por cada una tenemos un costo de $\mathcal{O}(n^2)$.
Este proceso de recorrer todas las casillas se repite para cualquier tablero vacío, creando $2^n -1$ instancias y llegando a una complejidad de $\mathcal{O}(n^2*2^{n^2})$ (el -1 es despreciable).\\
Ahora lo que sucede cuando contamos con caballos preubicados en un tablero cualquiera es que la comparación realizada en la linea 12 de Figura Backtracking, nos ahorra la creacion y copia del nuevo tablero, restando un $\mathcal{O}(n^2)$ a nuestra complejidad. A su vez, la cantidad de ramas con posibles soluciones se ven reducidas considerablemente resultando en $2^{n^2-k}$ instancias.\\
En conclusión nuestro algoritmo, en el peor caso, dado que no hay caballos prefijados, tiene la complejidad de $\mathcal{O}(n^2*2^{n^2})$.

\vspace*{0.6cm}

%\newpage
\subsection{Experimentación y gráficos.}

\vspace*{0.3cm}

\subsubsection{Test 1}

\vspace*{0.3cm}

\textbf{completar!}


\newpage
\subsubsection{Test 2}

\vspace*{0.3cm}

\textbf{completar!}


\newpage
\subsubsection{Test 3}

\vspace*{0.3cm}

\textbf{completar!}
