\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{charter}   % tipografía
\usepackage{graphicx}
\usepackage{makeidx}

\usepackage{float}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsfonts}
\usepackage{sectsty}
\usepackage{wrapfig}
\usepackage{listings} % necesario para el resaltado de sintaxis
\usepackage{caption}
\usepackage{placeins}

\usepackage{hyperref} % agrega hipervínculos en cada entrada del índice
\hypersetup{          % (en el pdf)
    colorlinks=true,
    linktoc=all,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\input{codesnippet}
\input{page.layout}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}
\usepackage{color}
\usepackage{clrscode3e} % necesario para el pseudocodigo (estilo Cormen)




\begin{document}

\lstset{
  language=C++,                    % (cambiar al lenguaje correspondiente)
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{red},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\thispagestyle{empty}
\materia{Algoritmos y Estructuras de Datos III}
\submateria{Primer Cuatrimestre de 2015}
\titulo{Diseño de Algoritmos}
\subtitulo{Aplicación de técnicas}
\integrante{Barañao, Facundo}{480/11}{facundo_732@hotmail.com}
\integrante{Confalonieri, Gisela Belén}{511/11}{gise_5291@yahoo.com.ar} % por cada integrante (apellido, nombre) (n° libreta) (e-mail)
\integrante{Mignanelli, Alejandro Rubén}{609/11}{minga_titere@hotmail.com} 
\integrante{Soliz, Carlos}{406/12}{rcarlos.cs@gmail.com} 

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
    \vspace{0.5cm}
	Este trabajo busca aplicar distintas técnicas para la creación de algoritmos. Para esto, se resolverán tres problemas que representan situaciones de la vida real y juegos de ingenio. Las técnicas que se utilizarán serán algoritmos golosos, divide and conquer y backtracking.

\end{abstract}

\thispagestyle{empty}
\vspace{1.5cm}
\tableofcontents
\newpage

%\normalsize

\newpage
\section{Objetivos generales}

El objetivo principal del siguiente trabajo será la práctica de distintas técnicas para la creación de algoritmos. Dados tres problemas, que representan situaciones factibles de la vida real y juegos de ingenio, se buscará resolverlos de forma óptima mediante la aplicación de algoritmos golosos, divide and conquer y backtracking.  En algunos de los casos, se buscará que el algoritmo no supere cierta cota de complejidad en peor caso.  Pretendemos mostrar cómo estas técnicas permiten mejorar los algoritmos frente a abordajes de ``fuerza bruta''.

\newpage
\section{Plataforma de pruebas}

Descripción de la plataforma de pruebas (hardware, software) utilizada
para el desarrollo y testeo del trabajo práctico.


\newpage
\section{Problema 1: Zombieland}
\input{problema1}

\newpage
\section{Problema 2: Alta Frecuencia}
\input{problema2}

\newpage
\section{Problema 3: El señor de los caballos}
\input{problema3}


\newpage
\section{Apéndice 1: acerca de los tests}

Incluye comentarios acerca de los tests utilizados, cómo generarlos y reproducirlos.


\newpage
\section{Apéndice 2: secciones relevantes del código}
En esta sección, adjuntamos parte del código correspondiente a la resolución de cada problema que consideramos más \textbf{relevante}.

\subsection{Código del Problema 1}

\begin{lstlisting}
typedef struct ciudad_t{
	int nombre; 			// numero que identifica la ciudad segun el orden en el que viene dada
    int cant_zombies;
    int cant_soldados;
    int soldier_req;  	// numero de soldados que faltan para salvar la ciudad
    int costfsoldier;  	// costo de enviar un soldado
    int costfsafety;  	// costo de salvar esa ciudad
    bool salvar;			// 1 para salvarla, 0 para no salvarla
} ciudad;
\end{lstlisting}

\vspace*{0.5cm}

\begin{lstlisting}
bool compare_cost(const ciudad& city1, const ciudad& city2){
	return (city1.costfsafety < city2.costfsafety);
}
\end{lstlisting}

\vspace*{0.5cm}

\begin{lstlisting}
bool compare_name(const ciudad& city1, const ciudad& city2){
	return (city1.nombre < city2.nombre);
}
\end{lstlisting}

\vspace*{0.5cm}

\begin{lstlisting}
int zombie_goloso(list<ciudad>& city, int p){
/* Devuelve la cantidad de ciudades que se salvan */

	int i = 0;
	int sum = 0;
	list<ciudad>::iterator it = city.begin();
    
    while(it != city.end() && (sum < p)){
		sum = sum + it->costfsafety;
		if (sum <= p){
			it->salvar = 1;
			i++;
		}
		it++;
	}
	return i;
}
\end{lstlisting}

\newpage
\subsection{Código del Problema 2}

\begin{lstlisting}
typedef struct frecuencia_t{
	int nombre; 			// numero que identifica la frecuencia segun el orden en el que viene dada
	int costfminute;  	// costo de uso por minuto
    int inicio;			// minuto inicio de transmision
    int fin;				// minuto fin de transmision
} frecuencia;
\end{lstlisting}

\vspace*{0.5cm}

\begin{lstlisting}
bool compare_time(const frecuencia& freq1, const frecuencia& freq2){
	return (freq1.inicio < freq2.inicio);
}
\end{lstlisting}


\newpage
\subsection{Código del Problema 3}

\begin{lstlisting}
typedef vector<char> Vec;
typedef vector<Vec> Tablero;
\end{lstlisting}

%\vspace*{0.5cm}

%\begin{lstlisting}
%int main(){
%  return 0;
%}
%\end{lstlisting}



\end{document}
